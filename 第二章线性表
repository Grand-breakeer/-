第二章线性表
（一）线性表的定义和基本操作
1。定义：线性表是具有相同数据类型的n个数据元素的有限序列。n为表长，n=0时线性表是一个空表L=(a1,a2,ai,.....an),ai是线性表中的第i个元素，除第一个元素外每个元素都有一个直接前驱，除最后一个元素外每个元素都有一个直接后继。
2.线性表的基本操作
（1）Inlist(&L):初始化线性表，分配内存空间。
（2）destroylist（&L）:销毁操作并释放线性表的内存空间。
（3）Listinsert（&L，i，e）插入操作在表中第i个位置上插入指定元素e。
等等。。。。
记忆思路：对数据的操作：创销增删改查。
定义操作名要具有明确的意义。

（二）顺序表的定义
第一节
1.定义：顺序表是指用顺序存储方式实现的线性表，顺序存储。把逻辑上相邻的元素存储在物理位置也相邻的存储单元中，元素之间的关系由存储项邻关系实现。
2.顺序表的实现－－静态分配

#define MaxSize 10
typedef struct{
			Elemtype data[MaxSize];
   int length;
}SqList;



相关事例代码
#include <stdio.h>
#define Maxsize 10
typedef struct{
   int data[MaxSize];
			int length;
}Sqlist;

void InitList(SqList &L){
   for(int i=0;i<MaxSize;i++）
						L.data[i]=0;
			L.length=0;
}

int main{
    SqList L;
    InitList(L);
     //后需相关操作
				return 0;
}

3.顺序表实现－－动态分配

#define InitSize 10
typedef struct{
    ElemType *data;
    int MaxSize;
    int length;
}SqList；



C语言提供的申请释放内存空间函数
malloc  free函数
C++
new delete

相关代码示例

#include <stdlib.h>
#define InitSize 10
typede struct{
    int *data;
    int MaxSize;
    int length;
}SqList;

void InitList(SqList &l){
L.data=(int *)malloc(InitSize*sizeof(int));
L.length=0;
L.MaxSize=InitSize;
}


//增加数据元素函数
viod IncreaseSize(SeqLisrt &L,int len){
				int *p=L.data;
    L.data=(int *)malloc((L.MaxSize+len)*sizeof(int));
				for(int i=0;i<L.length:i++){
				l.data[i]=p[i];
   }
			L.MaxSize=L.MaxSize+len;
   free(p)
}//也可以使用realloc函数，但是此函数使用问题较多。

int main(){
				SqLise L;
    InitList(L);
    InsreaseSize(L,5);
				return 0;
}

顺序表的特点
1.随机访问，可以在单位时间内找到第i个元素。
2.顺序表的存储密度较高，每个节点只存储数据元素。
3.拓展容量不方便。

第二节
顺序表的插入刹删除操作

ListInsert(&L,i,e):插入操作，在表i中第i个位置上插入元素e

顺序表的插入具体代码实现
#include <stdio.h>
#define Maxsize 10
typedef struct{
   int data[MaxSize];
			int length;
}Sqlist;

void ListInsert(Sqlist &L,int i,int e){
				if(i<1||i>L.length+1)
							retuen false;
    if(L.length>=MaxSize)
							return false;

    for(int j=L.lenth;j>=i;j--)
       L.data[j]=L。data[j-1];
    L.data[i-1]=e;
    L.length++;
}

int main(){
				SqLise L;
    InitList(L);
    //省略相关操作

				ListInsert(SqList &L,int i,int e)
				return 0;
}


顺序表的删除具体代码实现
#include <stdio.h>
#define Maxsize 10
typedef struct{
   int data[MaxSize];
			int length;
}Sqlist;

bool ListDelete(SqList &L,int i,int &e){
    if(i<1||i>L.length)
        return false;
    e=L.data[i-1];
    for(int j=i;j<L.length;j++)
							L.data[j-1]=L.data[j];
    L.length--;
    return true;
}

int main(){
				SqLise L;
    InitList(L);
    int e=-1;
    if(ListDelete(L,3,e)
						printf("已删除第i个元素，删除的元素为嗯”）;
				else
						printf("删除位序不合法");

				return 0;
}

第三节
顺序表的查找操作

GetElem(L,i)按位查找操作


#include <stdio.h>
#define Maxsize 10
typedef struct{
   ElemType *data;//指示动态分配数组的指针，相关知识点是C语言中数组与指指针之间的相互关系，以及二者中间的等价转换。
			int MaxSize;
			int length;
}Sqlist;

ElemType GetElem(SeqList L,int i){
   return L.data[i-1];
}

int main(){
				SqLise L;
    InitList(L);
    GetElem(SqList L,int i)
				return 0;
}


LocateElem(L,e)按值查找操作

#include <stdio.h>
#define Maxsize 10
typedef struct{
   int *data；
			int MaxSize;
			int length;
}Sqlist;

int LocateElem(SeqList L,int e){
    for(int i=0;i<L.length;i++)
       if(L.data[i]==e)//C语言中的结构体是不可以直接比较的
             return i+1;
				return 0;
}

int main(){
				SqLise L;
    InitList(L);
    LocateElem(SqList L,int e);
				return 0;
}






















